.readCounts <- function(files) {
    ans <- NULL
    for(f in files) {
        dx <- read.table(f, sep='\t', header=TRUE)
        names(dx)[1] <- "gene_id"
        if(is.null(ans)) ans <- dx
        else ans <- full_join(ans, dx, by="gene_id")
    }
    if(is.null(ans)) return(ans)
    rownames(ans) <- ans$gene_id
    ans %>% select(-gene_id)
}

xround <- function(x) round(x, digit=3)

#' General function
#'
#' The function name is self explained.
#' @title Convert NA to zero
#' @param x numeric vector 
#' @return numeric vector
#' @author ZG Zhao
#' @export
na2zero <- function(x){x[is.na(x)] <- 0; x}

#' For RSEM data: calculate mean or sd of gene expression values (CPM or TMM).
#'
#' Raw data is generated by "abundance_estimates_to_matrix.pl --est_method RSEM" (trinityrnaseq unitility)
#' @title RSEM only: calculate gene expressions
#' @param d.path path to the folder containing "gene.count.matrix" files
#' @param g.type gene type: "gene" or "isoform"
#' @param d.type data type: "mean" or "sd"
#' @param CPM TRUE/FALSE. If TRUE (default) return CPM, otherwise return TMM.
#' @return tibble, first column is "gene_id"
#' @author zhao
#' @export
RSEM_expression <- function(d.path, g.type="gene", d.type="mean", CPM=TRUE) {
    if(CPM)
        patx <- paste0("\\.", g.type, "\\.counts\\.matrix$")
    else
        patx <- paste0("\\.", g.type, "\\.TMM\\.EXPR\\.matrix$")
    
    files <- list.files(d.path, pattern=patx, full.names = TRUE)
    ans <- NULL
    for (fx in files) {
        anx <- NULL
        if(CPM) {
            dxx <- .readCounts(fx) %>%
                DGEList(remove.zeros = FALSE) %>%
                cpm() %>% as.matrix()
        } else {
            dxx <- .readCounts(fx) %>% as.matrix
        }
        if(d.type == "mean") vals <- rowMeans(dxx, na.rm=TRUE)
        else vals <- MatrixGenerics::rowSds(dxx, na.rm = TRUE)
        anx <- tibble(gene_id=rownames(dxx))
        spx <- sub(patx, "", basename(fx))
        anx[[spx]] <- vals
        
        if(is.null(ans)) ans <- anx
        else ans <- full_join(ans, anx, by="gene_id")
    }
    ans %>% mutate(across(where(is.numeric), xround))
}

#' RSEM only function
#'
#' Refer to function `DEGlist` in `edgeR` and `lmFit` in `limma` package.
#' @title Two-sample comparison for DEG identification.
#' @param d.path path to the folder containing "gene.count.matrix" files
#' @param control character, control sample (single)
#' @param treatment character, treatment sample (single)
#' @param g.type gene type: "gene" or "isoform"
#' @return tibble
#' @author ZG Zhao
#' @export
RSEM_comparison <- function(d.path, control, treatment, g.type="gene"){
    if(length(control) != 1 | length(treatment) != 1)
        stop('Please set one control and one treatment only!')
    smps <- c(treatment, control)
    ffs <- file.path(d.path, paste(smps, g.type, "counts.matrix", sep="."))
    if(any(! file.exists(ffs)))
        stop('Error sample labels, please check!')
    
    ## control
    ff1 <- file.path(d.path, paste(control, g.type, "counts.matrix", sep="."))
    dx1 <- read.table(ff1, sep='\t', header=TRUE)
    nc1 <- ncol(dx1) - 1
    names(dx1)[1] <- "gene_id"
    ## treatment
    ff2 <- file.path(d.path, paste(treatment, g.type, "counts.matrix", sep="."))
    dx2 <- read.table(ff2, sep='\t', header=TRUE)
    nc2 <- ncol(dx2) - 1
    names(dx2)[1] <- "gene_id"

    ## join
    expr_counts <- full_join(dx1, dx2, by='gene_id')
    rownames(expr_counts) <- expr_counts$gene_id
    expr_counts <- expr_counts[, -1] %>%
        mutate(across(everything(), na2zero))
    expr_counts <- expr_counts[rowSums(cpm(expr_counts) > 1) >= 2,]
    
    ## limma
    conditions <- factor(c(rep(control, nc1), rep(treatment, nc2)),
                         levels = c(control, treatment))
    design <- model.matrix(~conditions)
    lib_sizes <- colSums(expr_counts)
    norm_scf <- calcNormFactors(expr_counts, method='TMM')
    x <- DGEList(counts=expr_counts)
    y <- voom(x, design, lib.size=lib_sizes*norm_scf, plot=F)
    fit <- eBayes(lmFit(y, design))
    fit_results <- topTable(fit,coef=2,number=Inf)

    ## arrange results
    as_tibble(fit_results) %>%
        mutate(gene_id=rownames(fit_results)) %>%
        select(gene_id, everything()) %>% 
        arrange(gene_id)
}

#' Before running this pipeline, you should get expression matrices using Trinity command: `abundance_estimates_to_matrix.pl --est_method RSEM`.
#'
#' Pipeline: export expression, run comparisons and get DEG lists.
#' @title RSEM only: data export after abundance estimated.
#' @param data_dir file path, typically the RSEM output folder.
#' @param treatments character vector, sample names.
#' @param controls character vector, sample names.
#' @param output_dir file path
#' @param isoform TRUE/FALSE (default). FALSE for genes, TRUE for isoforms.
#' @param CPM TRUE/FALSE. If TRUE (default) return CPM, otherwise return TMM.
#' @param DEG.fc numeric, log(fold_changed) threshold.
#' @param annotations supply a gene annotation data.frame with `gene_id` column if you want to include gene annotation for DEGs.
#' @return NULL. Data will be saved to output dir.
#' @author ZG Zhao
#' @export
RSEM_pipeline <- function(data_dir, treatments, controls,
                          output_dir="data", isoform=FALSE, CPM=TRUE,
                          DEG.fc=1, annotations=NULL){
    samples <- list.files(data_dir, pattern="\\.gene\\.counts\\.matrix$")
    if(length(samples) < 1)
        stop(paste0('The folder `', data_dir, '` is not a valid RSEM output folder!'))
    
    if(! dir.exists(output_dir)) dir.create(output_dir, recursive=T)
    
    ## export expression data
    g.type <- if(isoform) "isoform" else "gene"
    exprs <- RSEM_expression(data_dir, g.type = g.type, d.type = "mean", CPM=CPM)
    fx <- file.path(output_dir, "all.exprs.mean.matrix.csv")
    write.csv(exprs, fx, row.names=FALSE)
    cat(paste("File exported:", fx, '\n'))
    sds <- RSEM_expression(data_dir, g.type = g.type, d.type = "sd")
    fx <- file.path(output_dir, "all.exprs.sd.matrix.csv")
    write.csv(sds, fx, row.names=FALSE)
    cat(paste("File exported:", fx, '\n'))

    ## export complete p table
    samples <- sub('\\.gene\\.counts\\.matrix$', '', samples)
    ns <- length(samples)
    dx <- select(exprs, gene_id)
    cat("Calculating pairwise p values ...\n")
    for (i in 1:(ns-1)) {
        for (j in (i+1):ns) {
            aa <- samples[i]
            bb <- samples[j]
            dx <- RSEM_comparison(data_dir, aa, bb, g.type=g.type) %>%
                select(gene_id, P.Value) %>%
                mutate(P.Value=round(P.Value, 3)) %>% 
                rename("{aa}-{bb}" := P.Value) %>%
                full_join(dx, by="gene_id")
        }
    }
    fx <- file.path(output_dir, "all.pairwise.p.matrix.csv")
    write.csv(dx, fx, row.names=FALSE)
    cat(paste("File exported:", fx, '\n'))
    
    ## export comparison matrices and DEG lists
    if(length(setdiff(c(treatments, controls), samples)) > 0)
        stop('Invalid sample names!')
    if(length(treatments) != length(controls))
        stop('Invalid comparisons!')
    
    for(i in 1:length(treatments)) {
        tx <- treatments[i]
        cx <- controls[i]
        fx <- file.path(output_dir, paste0('compare.', tx, '_vs_', cx, ".csv"))
        dx <- RSEM_comparison(data_dir, cx, tx, g.type=g.type) %>%
            ## select(gene_id, logFC, P.Value) %>% 
            ## left_join(exprs %>% select(gene_id, {{tx}}, {{cx}}) %>%
            ##           rename("{tx}_mean":={{tx}}, "{cx}_mean":={{cx}}),
            ##           by="gene_id") %>%
            ## left_join(sds %>% select(gene_id, {{tx}}, {{cx}}) %>%
            ##           rename("{tx}_sd":={{tx}}, "{cx}_sd":={{cx}}),
            ##           by="gene_id") %>%
            mutate(across(where(is.numeric), round, digit=3)) %>%
            select(gene_id, matches("_mean|_sd"), everything()) 
        write.csv(dx, fx, row.names=FALSE)
        cat(paste("File exported:", fx, '\n'))
        ## export DEG lists
        dx <- select(dx, gene_id, logFC, P.Value) %>%
            rename(P=P.Value) %>% 
            filter(abs(logFC) > abs(DEG.fc), P < 0.05) %>%
            mutate(P=p.adjust(P, 'fdr', n()),
                   P=round(P, 3)) %>%
            filter(P < 0.05)
        if(! is.null(annotations))
            dx <- left_join(dx, annotations, by = 'gene_id')
        fx <- sub('compare', 'DEG', fx)
        write.csv(dx, fx, row.names=F)
        cat(paste("File exported:", fx, '\n'))
    }
}

.rsem_read_expression <- function(ddir, smps){
    mm <- read_csv(file.path(ddir, "all.exprs.mean.matrix.csv"),
                   show_col_types = FALSE) %>%
        select(gene_id, all_of(smps)) %>%
        pivot_longer(cols=-gene_id, names_to = "sample", values_to = "mean")
    dd <- read_csv(file.path(ddir, "all.exprs.sd.matrix.csv"),
                   show_col_types=FALSE) %>%
        select(gene_id, all_of(smps)) %>%
        pivot_longer(cols=-gene_id, names_to = "sample", values_to = "sd")
    full_join(mm, dd, by=c('gene_id', 'sample'))
}

.setSigLetters <- function(dfx, data_dir) {
    ss <- unique(dfx$sample)
    gg <- unique(dfx$gene_id)
    pmx <- read_csv(file.path(data_dir, 'all.pairwise.p.matrix.csv'),
                    show_col_types=FALSE)
    nn <- lapply(names(pmx), FUN=function(x) strsplit(x, "-")[[1]]) %>%
        sapply(FUN=function(x) all(x %in% ss))
    pmx <- pmx %>% select(gene_id, which({{nn}})) %>%
        filter(gene_id %in% {{gg}})
    ans <- NULL
    for(i in 1:nrow(pmx)) {
        xxx <- unlist(pmx[i, -1])
        xxx[is.na(xxx)] <- 1
        xxx <- multcompLetters(xxx)$Letters
        anx <- tibble(sample=names(xxx), sigLett=xxx)
        anx$gene_id <- pmx$gene_id[i]
        ans <- bind_rows(ans, anx)
    }
    dfx %>% full_join(ans, by=c("gene_id", "sample"))
}

.evfilter <- function(df, v) {
    df %>% group_by(gene_id) %>%
        summarise(zz=max(mean, na.rm=T),
                  sigPos=max(mean+sd)*0.1) %>%
        filter(zz > {{v}}) %>% select(-zz) %>%
        left_join(df, by='gene_id') %>%
        mutate(sigPos=mean+sd+sigPos)
}

#' Get expression data (mean, sd and significant letters) for visulization (plotCPM )
#'
#' Get expression data
#' @title RSEM only: pull/extract after \code{\link{RSEM_pipeline}}
#' @param data_dir character, directory/folder where RSEM pipeline results saved.
#' @param gids character vector, gene ids.
#' @param smps character vector, sample names.
#' @param min.cpm numeric. Genes whose max level is less than min.cpm will be omitted.
#' @return tibble
#' @author ZG Zhao
#' @export
RSEM_pull_expression <- function(data_dir, gids, smps, min.cpm=-1) {
    ans <- NULL
    smps <- unique(smps)
    n <- length(smps)
    .rsem_read_expression(data_dir, smps) %>%
        filter(gene_id %in% {{gids}}) %>% 
        arrange(gene_id, sample) %>%
        .setSigLetters(data_dir=data_dir) %>%
        .evfilter(v=min.cpm) %>%
        select(gene_id, mean, sd, sigLett, sigPos, everything())
}

#' Read and combine (intersect or union) gene ids.
#'
#' Convenient function to perform intersection of union.
#' @title function read_DEGs
#' @param files file paths to "DEG" files generated by \code{\link{RSEM_pipeline}}
#' @param g.union TRUE/FALSE. Get union or intersect of gene ids.
#' @return character vector of gene ids
#' @author ZG Zhao
#' @export
read_DEGs <- function(files, g.union=FALSE) {
    n <- length(files)
    ans <- NULL
    for(i in 1:length(files)) {
        gids <- read.csv(files[i])$gene_id
        if(i < 2 && ! g.union)
            ans <- gids
        else if (! g.union)
            ans <- intersect(ans, gids)
        else
            ans <- union(ans, gids)
    }
    ans
}

#' Read and combine logFC.
#'
#' Combie logFC for downstream analysis.
#' @title function read_logFCs
#' @param files file paths to "compare" files generated by \code{\link{RSEM_pipeline}}
#' @param labs character vector. 
#' @return tibble
#' @author ZG Zhao
#' @export
read_logFCs <- function(files, labs=NULL) {
    nf <- length(files)
    if(is.null(labs)) {
        labs <- basename(files)
        labs <- sub("^compare\\.(.+)\\.csv", "\\1", labs)
    }
    if(!is.null(labs) && nf != length(labs))
        stop("Un-matched file and label length!")
    exprs <- NULL
    for(i in 1:nf) {
        fx <- files[i]
        gg <- labs[i]
        dxx <- read_csv(fx, show_col_types = F) %>%
            select(gene_id, logFC) %>% 
            rename("{gg}" := logFC)
        if(is.null(exprs)) exprs <- dxx
        else exprs <- left_join(exprs, dxx, by='gene_id')
    }
    na2zero(exprs)
}
